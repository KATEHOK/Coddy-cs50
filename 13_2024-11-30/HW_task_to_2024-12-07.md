# К занятию 2024-11-30

## Теория

На последнем занятии мы посмотрели часть ваших домашек (тех, кто ее делал и принес).

После этого мы посмотрели видео о том, как пишется, компилируется и запускается простейшая программа на языке C:

[#3. Структура и понимание работы программы "Hello, World!" | Язык C для начинающих | selfedu | YouTube](https://youtu.be/TgjwJJ4IZQE?si=BL0FRkefAF2YrExe)

После просмотра видео мы написали программу, решающую первую задачу из предыдущего дз.

В этом [файле](./hw.c) можете посмотреть код с урока.

### Функции (продолжение)

Рассматривать функции мы начали еще неделю назад (23 ноября), по этой [ссылке](../12_2024-11-23/HW_task_to_2024-11-30.md) вы найдете файл с теорией того урока. В дополнение к нему настоятельно рекомендую посмотреть видео, в которых автор подробно рассказывает о функциях в языке C:
[#40. Объявление и вызов функций | Язык C для начинающих | selfedu | YouTube](https://youtu.be/nlVj5rOtLVw?si=YYMaGcV3baRp1Fm8)

#### Прототипы функций

Более полно прочитать о прототипах функций можете по этой [ссылке](https://metanit.com/c/tutorial/4.1.php) (промотайте вниз до заголовка "Прототип или описание функции").

На предыдущем занятии мы создавали свои функции до функции `main`, внутри которой мы вызывали наши собственные функции.

```c
#include <stdio.h>
 
void hello() {
    printf("Hello!\n");
}
 
int main() {   
    hello();
    hello();
    return 0;
}
```

С ростом нашей программы у нас будет появляться все больше и больше функций, и в какой-то момент может оказаться, что до нашей функции `main` будет огромная часть кода, что не добавляет удобства в разработке (а также считается плохим тоном). Чтобы решить эту проблему, можно перенести определения наших функций после функции `main`.

```c
#include <stdio.h>
 
int main() {   
    hello();
    hello();
    return 0;
}
 
void hello() {
    printf("Hello!\n");
}
```

Однако при попытке скомпилировать такую программу компилятор выдаст ошибку, так как на момент вызова `hello` внутри `main` он еще не будет знать о существовании такой функции. В процессе компиляции программы на этапе создания объектного модуля компилятор должен знать сигнатуру вызываемых функций (то есть, тип возвращаемого значения, название функции, а также типы передваемых в нее аргументов). Эту проблему можно решить, используя механизм объявления функций.

```c
#include <stdio.h>

// Объявление (прототип) функции hello
void hello();

int main() {   
    hello();    // вызов функции
    hello();    // вызов функции
    return 0;
}

// Определение функции hello
void hello() {
    printf("Hello!\n");
}
```

Теперь компиляция будет выполнена успешно, так как на момент вызова функции `hello` компилятор уже имеет представление о ее сигнатуре.

Общий синтаксис объявления функции следующий:
```c
<тип возвращаемого значения> <имя функции>(<типы и названия параметров>);
```

Типом возвращаемого значения может служить любой тип данных (`int`, `float`, `char`, и тд) или же тип `void` (пустой) - для случаев, когда наша функция не возвращает никакого значения (как в примере с функцией `hello`, которая лишь выводит приветственное сообщение в консоль).

## Домашка

Выполнять задание можете в любом удобном редакторе кода, только учтите, что вы должны иметь возможность компилировать и запускать программу.

Рекомендую использовать:

1) VSCode с установленным компилятором (например, по гайду: [#2. Установка компилятора gcc и Visual Studio Code на ОС Windows | Язык C для начинающих | selfedu | YouTube](https://youtu.be/TGpYh9X1PYk?si=d-czlTp61j4xqeGc) (предпочтительный вариант) или [Install gcc compiler 2024-11-16 | Katehok | YouTube](https://youtu.be/9h7KRt1w1Dc?si=g4nHwqL6HzXzmI0k))
2) Онлайн codespace от cs50: https://cs50.dev/
3) Онлайн IDE + компилятор: https://www.online-cpp.com/online_c_ide
4) MS Visual Studio
5) Любая другая связка редактора кода + компилятора

В любом случае, для сдачи домашки у вас должна быть возможность показать код мне. При этом как именно вы это сделаете - файл или архив файлов с кодом пришлете в ТГ или принесете их на флешке - не столь важно (единственное, код должен быть в виде текста, а не фотографии или скриншота). Учтите, что код должен быть полностью рабочим, и мне достаточно будет лишь скомпилировать его, не внося никаких исправлений.

На этот раз какой-либо новой домашки не будет, так как никто не выполнил все задачи из предыдущего задания. Поэтому на этот раз вы должны полностью доделать все четыре задачи из предыдущего задания (тем, кто делал какие-то из них к сегодняшнему разу, будет попроще). То есть, 7 декабря вы должны будете мне предоставить все полностью 4 выполненные задачи.

Напомню, что все задачи должны быть решены в одном файле в виде отдельных функций.

Из новых требований будет только одно: для каждой своей функции нужно создать прототип и поместить его до функции `main`, а сами реализации своих функций должны быть написаны уже после функции `main`, как это было показано на [примере с урока](./hw.c).