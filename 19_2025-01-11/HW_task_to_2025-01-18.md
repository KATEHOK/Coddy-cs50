# К занятию 2025-01-18

На последнем занятии мы разобирали рекурсивный вызов функций и один из вариантов написания автотестов.

[Файл](./main.c) с кодом с занятия.

## Теория

### Рекурсивные функции на языке C

Рекурсивная функция — это такая функция, которая вызывает сама себя.
Это похоже на задачу, где для решения проблемы нужно сначала решить её меньшую часть.
Важно, чтобы у функции был базовый случай, который завершает её вызовы, иначе программа зациклится.

#### Пример: рекурсивное умножение

Давайте разберёмся, как с помощью рекурсии можно умножать два числа. Рассмотрим функцию:

```c
// Рекурсивно вычисляет произведение двух целых чисел
int mul(int first, int second) {
    // x * 0 = 0
    if (second == 0) return 0;                      // Базовый случай: если второе число 0, результат тоже 0

    // x * y = -(x * -y)            | для y < 0
    if (second < 0) return -mul(first, -second);    // Если второе число отрицательное

    // x * y = [x * (y - 1)] + x    | для y >= 0
    return mul(first, second - 1) + first;          // Уменьшаем второе число и добавляем первое
}
```

**Как это работает**

1. **Базовый случай**:  
   Если второе число (`second`) равно 0, результат умножения тоже будет 0. Это завершает рекурсию.

2. **Отрицательные числа**:  
   Если второе число отрицательное, мы меняем его на положительное, а результат берём с отрицательным знаком.

3. **Рекурсивный случай**:  
   Если второе число положительное, функция уменьшает его на 1 и прибавляет первое число к результату.
   Так мы сводим задачу умножения к более простой: сложению чисел.

#### Пример выполнения

Допустим, мы хотим вычислить `-5 * 3`. Вот как это происходит шаг за шагом:

1. **Шаг 1:** `mul(-5, 3)`  
   Второе число (`3`) больше 0. Функция вызывает сама себя:  
   `mul(-5, 2) + (-5)`

2. **Шаг 2:** `mul(-5, 2)`  
   Второе число (`2`) больше 0. Функция вызывает сама себя:  
   `mul(-5, 1) + (-5)`

3. **Шаг 3:** `mul(-5, 1)`  
   Второе число (`1`) больше 0. Функция вызывает сама себя:  
   `mul(-5, 0) + (-5)`

4. **Шаг 4:** `mul(-5, 0)`  
   Второе число (`0`). Базовый случай: функция возвращает `0`.

Теперь возвращаемся назад:

- `mul(-5, 0)` вернуло `0`. Значит, `mul(-5, 1)` равно `0 + (-5) = -5`.  
- `mul(-5, 1)` вернуло `-5`. Значит, `mul(-5, 2)` равно `-5 + (-5) = -10`.  
- `mul(-5, 2)` вернуло `-10`. Значит, `mul(-5, 3)` равно `-10 + (-5) = -15`.

Итог: `-5 * 3 = -15`.

#### Плюсы и минусы рекурсии

**Плюсы:**
- Легче понять логику решения сложных задач.
- Код становится более компактным.

**Минусы:**
- Рекурсия использует больше памяти, так как каждая функция сохраняется в стеке вызовов.
- Если не указать базовый случай, программа может "зависнуть".

#### Заключение

Рекурсивные функции — это мощный инструмент для решения задач, которые можно свести к более простым подзадачам.
Важно понимать базовый случай и не забывать, как сводить проблему к меньшей части.
В примере с умножением мы смогли умножить два числа, используя простое сложение и рекурсию!

### Автоматическое тестирование (автотесты) на примере функции `mul`

Автотесты позволяют автоматически проверять правильность работы функции или программы.
Вместо того чтобы вручную запускать программу с разными входными данными и проверять результат,
мы можем написать код, который сделает это за нас.

#### Пример автотестов для функции `mul`

```c
// Тестирует функцию mul
void test_mul();

int main() {
    test_mul();
    return 0;
}

void test_mul() {
    // Перебираем диапазон значений для проверки
    for (int i = -10; i <= 10; ++i) {
        for (int j = i; j <= 10; ++j) {
            // Вычисляем результат функции mul (из предыдущего пункта) и ожидаемое значение
            int res1 = mul(i, j), res2 = mul(j, i), exp = i * j;

            // Если результат некорректен, выводим ошибку
            if (res1 != exp || res2 != exp) {
                printf(
                    "Некорректное значение:\n"
                    "mul(%d, %d) -> %d\n"
                    "mul(%d, %d) -> %d\n"
                    "%d * %d -> %d\n",
                    i, j, res1,
                    j, i, res2,
                    i, j, exp
                );
            }
        }
    }
}
```

#### Как работает `test_mul`

1. **Циклы для тестирования:**  
   В тестах мы перебираем все числа от `-10` до `10` для обеих переменных (`first` и `second`). Это 231 пара значений для проверки.

2. **Результат функции и ожидаемое значение:**  
   - `res1 = mul(i, j)` — результат вызова `mul` с первым числом `i` и вторым числом `j`.
   - `res2 = mul(j, i)` — проверка коммутативного свойства умножения (от перемены мест множителей произведение не меняется).
   - `exp = i * j` — ожидаемое значение (используем встроенный оператор `*`).

3. **Сравнение результатов:**  
   Если хотя бы один результат (`res1` или `res2`) не совпадает с ожидаемым (`exp`),
   выводится ошибка с подробным описанием входных данных и некорректного результата.

#### Пример вывода ошибки

Если в функции `mul` есть ошибка, программа выведет что-то вроде:

```
Некорректное значение:
mul(-5, 3) -> -14
mul(3, -5) -> -14
-5 * 3 -> -15
```

Это значит, что функция возвращает неправильное значение для `-5 * 3` и `3 * -5`. Ожидаемое значение равно `-15`.

#### Преимущества автотестов

1. **Быстрая проверка:** Тесты выполняются за доли секунды, даже если проверяется большое количество данных.
2. **Устойчивость к изменениям:** Если функция изменится, автотесты сразу покажут, не нарушилась ли её работа.
3. **Удобство:** Все тесты запускаются автоматически, без ручного ввода данных.

Автотесты помогают делать программы более надёжными и экономить время на проверке!

## Домашка

Выполнять задание можете в любом удобном редакторе кода, только учтите, что вы должны иметь возможность компилировать и запускать программу.

Рекомендую использовать:

1) VSCode с установленным компилятором, например, по одному из гайдов:
    - [#2. Установка компилятора gcc и Visual Studio Code на ОС Windows | Язык C для начинающих | selfedu | YouTube](https://youtu.be/TGpYh9X1PYk?si=d-czlTp61j4xqeGc) (предпочтительный вариант)
    - [Install gcc compiler 2024-11-16 | Katehok | YouTube](https://youtu.be/9h7KRt1w1Dc?si=g4nHwqL6HzXzmI0k)
2) Онлайн codespace от cs50: https://cs50.dev/
3) Онлайн IDE + компилятор: https://www.online-cpp.com/online_c_ide
4) MS Visual Studio
5) Любая другая связка редактора кода + компилятора

Напомню, что все задачи должны быть решены в одном файле в виде отдельных функций.

Помните: для каждой своей функции нужно создать прототип и поместить его до функции `main`, а сами реализации своих функций должны быть написаны уже после функции `main`, как это показано в [файле с урока](./main.c) (можете использовать код из него в качестве примера).

### Критерии выполненного задания (для заданий с программированием)

1) Исходный код (файлом или текстом на языке C) прислан (в телеграме/вотсапе/по почте России) или принесен на урок (на флешке).

2) Код не содержит ошибок, то есть спокойно компилируется в исполняемый файл, не выводя предупреждений или ошибок.

3) Скомпилированная программа успешно запускается и корректно завершается (с кодом 0).

4) Программа в точности реализует решение задачи, а также соответствует всем дополнительным критериям, если таковы указаны в условии задачи.

Критерии могут быть изменены или дополнены для конкретной задачи, о чем будет сказано в ее условии.

### GCC и VSCode

Во-первых, если вы до сих пор не установили компилятор GCC и/или среду разработки VSCode, необходимо сделать это. Инструкция по установке - в видео одного из [предыдущих занятий](../15_2024-12-14/HW_task_to_2024-12-21.md).

Если у вас возникнут проблемы с просмотром видео, то пишите мне в телегу - помогу.

### Компиляция и запуск

Напомню, что для того, чтобы скомпилировать код, нужно в терминале перейти в папку с файлом кода (вспоминайте команду `cd` или как открыть терминал в нужной папке) и выполнить команду:

```
gcc -o <program.exe> <c-file.c>
```

Где `<program.exe>` название файла, которое хотите сделать для ващей программы; `<c-file.c>` - название вашего файла с кодом на языке C.

Чтобы запустить скомпилированную программу, выполните:

```
./<program>
```

Где `<program>` - название программы, которую хотите запустить.

### Факториал числа

Факториал числа - математическая функция для целых неотрицательных чисел.
По сути - произведение всех натуральных чисел, меньших указанного аргумента.
Например, факториал числа `5` (записывается: `5!`) равен: `5! = 5 * 4 * 3 * 2 * 1 = 120`.
Также определено, что факториал нуля равен единице: `0! = 1`.

Можно заметить, что факториал числа `n` можно легко вычислить, если известен факториал числа, на `1` меньшего, чем `n`: `n! = (n - 1)! * n`.
Такая формула справедлива для всех натуральных `n`, а для `n = 0: n! = 1` (по определению).
В математике подобные формулы называют *рекурентными*, и с помощью рекурсивных функций их очень легко считать.

Тогда определение факториала можно записать следующим образом:
```
0! = 1
n! = (n - 1)! * n, для всех натуральных n
```

Итак, ваша задача - **написать функцию `factor`, рекурсивно вычисляющую факториал целых неотрицательных чисел**.

Важно: предусмотреть ситуацию, если пользователь захочет вызвать функуию для отрицательных аргументов (вернуть ноль).

#### Дополнительно

Если успешно справились с рекурсивным вычислением факториала, реализуйте его вычисление с помощью цикла(ов).

### Степень числа

Неотрицательная степень числа - математическая функция, равная произведению основания степени на само себя `m` раз, где `m` - показатель степени (`m >= 0`). При этом определено, что при `m = 0`: `n ^ m = 1` для любого ненулевого целого `n`.
```
n ^ m = n * n * ... * n (умножается m раз)
```
Например: `2 ^ 5 = 2 * 2 * 2 * 2 * 2 = 32`, `0 ^ 962835 = 0`, `(-67896) ^ 0 = 1`, `0 ^ 0 = не определено` (последний результат - из-за того, что ноль при умножении на любое число дает ноль, при этом любое число в нулевой степени дает единицу - конфликт).

Степень числа также является геометрической прогрессией (каждый следующий член больше предыдущего в `n` раз).
Как и любую геометрическую прогрессию, степень числа можно определить с помощью рекурентной формулы:
```
0 ^ m = 0,                      для любого натурального m
n ^ 0 = 1,                      для любого целого и ненулевого n
n ^ m = ( n ^ (m - 1) ) * n,    для любого целого n и натурального m
```

Итак, ваша задача - **написать функцию `my_pow`, рекурсивно вычисляющую неотрицательную степень целого ненулевого числа**.

Важно: предусмотреть ситуацию, если пользователь захочет вызвать функуию для отрицательного показателя или для одновременно нулевых основания и показателя (вернуть ноль).

#### Дополнительно

Если успешно справились с рекурсивным вычислением степени, реализуйте ее вычисление с помощью цикла(ов).

### Тестирование степени числа

Подключить библиотеку `math.h` при помощи директивы `#include`:
```c
#include <math.h>
```

Из этой библиотеки нас пока что интересует только функция `pow` - для вычисления степени целых чисел.

Итак, ваша задача - **написать функцию `test_my_pow`**, реализующей автотест для функции `my_pow`,
в качестве эталонных значений используйте результаты вызова функции `pow` для таких же аргументов.
Если какой-либо тест будет завален, выведите информацию: чему равны `n` и `m`, а также результаты вызовов: `my_pow(n, m)` и `pow(n, m)`.
После всех проверок функция должна напечатать что-то типа: `Все тесты пройдены`.

Тестировать необходимо для следующих значений аргументов:
- `n`: -100, -99, ..., -1, 0, 1, ... 99, 100;
- `m`: 0, 1, ... 100.

Важно: для одновременно нулевых основания и показателя проверку не выполнять (библиотечная функция должна крашнуть работу).

**Удачи!)**